# Project Definitions

## Semester Projects

The following are projects suitable for the equivalent of the final. Groups of 2-3 are expected to take 8 weeks to program these, write up a document, and present.

## Final Projects Grading and Rubric

- 7% Setup and library research
  - 3% Repository structure
    - ref directory contains all papers cited and any other supporting materials such as code found
    - Repository setup with specified directories
    - README.md describes project
    - Report is in doc directory
    - Code is clearly written, formatted, and well-commented
    - No dead files
    - Project build should be accomplished with standard tools
      - For Java: maven (mvn), ant or equivalent
      - For C++: make or cmake
    - Clear documentation including
      - Description of all files and what they mean
      - Resources required to run the project
      - How to run your code
  - 2% Algorithms and data structures are clearly described
    - With diagrams where appropriate
    - Diagrams are drawn by you in [diagrams.net](https://app.diagrams.net) or equivalent tool, ideally stored as .svg (scalable, not an image so that digrams can be enlarged). Note: plugin available for vscode! draw.io
  - 1% Setup of overleaf (share with me and TA) including .bib file for bibliography
  - 1% Meeting with librarian and papers put into ref directory of repository [See: research guide](research_guide.md)
- 30% weekly work, as measured by checkins into your repo
  - Each week, progress must be pushed to the repository.
  - If you are not able to write code, then diagrams and notes should be pushed up showing your team's progress.
  - Failure to show steady progress results in a zero for that week.
  - No matter how good your project is, doing it all the last minute will earn you a maximum of 70%. Be sure to work steadily all through the semester.
- 30% Either how well the code works, or if a theory project, the quality of your research.
  + Code demonstrates working algorithm
  + Code is efficient
  + You have correctly analyzed the complexity of the algorithm as you have implemented it.
  + Theory shows you have understood existing work and have defined a potentially workable algorithm
  + It is possible that you prove that your algorithm does not work, and that is an acceptable result. However, you must clearly show why your idea did not work.
- 15% Final presentation
  - Clarity. The team clearly explained the project and the algorithms used.
  - Graphics. The slides to present the work are clear and visually appealing
  - Presentation is polished, you have practiced and know the material
- 15% Final Paper
  - Paper is in specified format
  - Abstract correctly presents overview of the paper
  - Paper must not mention names of the authors, me, or this course. The paper is about a topic. Any mention of how you feel about the topic, or yourselves is irrelevant. The only place where you may mention names is in acknowledgements, where you may (and should) thank anyone who helped.
- 3% Feedback on other projects
  - Each individual is expected to attend (or watch video) of all presentations
  - For each project answer the following 3 questions
    - What did you learn about this topic from the presentation?
    - What did the presentation not cover that you wish it did?
    - In your opinion, how could the presentation have been improved? (Note: this will not be shared with anyone else)
  - List top 3 projects in your opinion

## Topics

* [Rope](rope/README.md)
* [Chain](chain/README.md)
* [Trie/Hash Compressed Dictionary](triehash/README.md)
* [Hashmap Compressed Dictionary](hashdict/README.md)
* Tree or Hashmap based dictionary for other languages
* [Least Squares Fit](leastsquaresfit/README.md)
* [Dictionary-based Compression](dictionarycompression/README.md)
* [Punctuation Dictionary](punctuationdictionary/README.md)
* [Serializable Hashmap Dictionary](serializablehashmap/README.md)
* [Navigation Simulation](navsim/README.md)
  - Navigation simulation would compare two of three methods of localization for robots
    - Kalman Filter
    - Particle Filter
    - Multiple Analytical Distribution Filter (MADF).
      - This was part of my PhD thesis
      - Evidently this idea is called Catagorical Particle Filter. My question is, did I invent it first? My paper was published in 2009 or so.
* [Incremental Shortest Path](incrementalshortestpath/README.md)
* [Plagiarism Detection Using Winnowing Algorithm](Winnowing/README.md)
* [Compression](compression/README.md)
* [Optimal Packing](optimalpacking/README.md)
* [Hardware Accelerated Sorting](hardwareacceleratedsorting/README.md)
* [Simple Parser](simpleparser/README.md)
* Your project goes here... Suggest one!


# Mini Projects

The following are small projects suitable for 2-3 people for 2-3 weeks.

* [Expression Tree](expressiontree/expressiontree.md)
* [Removing Common Headers/Footers from Gutenberg](removingcommon/README.md)
* Comparison of sorting algorithms (Quicksort, Knuth-Optimized Quicksort)

## Programming homework proposals

* [Jeffrey-Collatz]() <!-- longest collatz using dynamic programming -->
* [backpack]() <!-- backtracking with minimal constraint -->
* [summarize Karp 21 problems?]()